Java Load Generator:

2. Be able to change transaction proportion on the fly from the rest interface.
3. Have return codes successfully passed between nodes.
5. Throughput needs to be able to detect the number of client machines and adjust appropriately.
6. server-list should correctly print out all servers in the cluster.


10. Implement the JsonStringDecoder class and have functions decoding JSON use it.
11. Have functions building JSON strings use the JsonStringBuilder class.
12. Make it so that certain parameters cannot be changed during runtime
19. Implement the stop feature to stop load generation from all nodes.
20. Get the working set implementation working and be able to use rest to manipulate values.
21. Solve the ec2 problem.

p1. Be able to do sets mixed with other transactions
p2. Be able to do deletes
p3. Be able to do incr
p4. Be able to do decr 

Java Membase Rest Interface:
1. Need to be able to define bucket sizes
2. Be able to define any number of replicas
3. Be able to define any number of nodes


Performance Requirements:

Machine HW spec (#cores & type)
Total node RAM
Number and type of disk(s) and config
OS version and bitness

Test Procedure
Test steps
Test duration
#iterations

Data Captured
latency
Throughput
Test duration
CPU usage
Memory usage
sar stats




Problems:

Remove the key prefix property form the parameter list and let each client generate its own unique prefix

- Lets say we have 2 nodes in the cluster and 10,000. If one node goes down we will get errors because the
cluster will now expect the node to see 10,000 keys, but it will only know about 5,000. A possible solution
is to give each node in the cluster a key range. When a node goes down leader in the cluster gives each node
a new key range to work on.